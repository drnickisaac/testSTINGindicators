---
title: "Test STING IDM v0.2"
author: "Nick Isaac"
date: "06/02/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load the packages, installing where required
required.packages <- c("nimble", "ggmcmc", "coda")
packages.to.install <- setdiff(required.packages, installed.packages())
if(length(packages.to.install) > 0)
  install.packages(packages.to.install)
library(nimble)
library(ggmcmc)
library(coda)

# for the phenology plot (could replace)
#if(!"sparta" %in% installed.packages())
#  devtools::install_github('BiologicalRecordsCentre/sparta')
#library(sparta)

#source("source/STING_sim_funcs.r")
```

Set some global parameters
```{r SetSimPars}
nSites <- 10
nVisits <- 2
sim.pars <- c(psi = 0.5, # proportion of occupied sites 
              mu.p1 = 0.5, # probability of detection at the peak of the phenology curve
              beta1 = 10, # date when detectability is highest (zero = 1st July)
              beta2 = 20) # standard deviation of detection phenology
```

Define the model code in Nimble
```{r}
modelcode <- nimbleCode({
  # state model
  for (i in 1:nsite) {
    z[i] ~ dbern(psi) # True occupancy status
  }  
  
  ######################### Obs model - pan traps
  for (i in 1:nsite) {
    for (j in 1:nvisit) {
      y1[i,j] ~ dbin(size = nT[i,j], prob = Py[i,j]) # Observed data
      Py[i,j] <- z[i] * p1[i,j]
      p1[i,j] <- mu.p1 * beta3 * f_JD[182 + cJulDate[i,j]]
  }}
  
  # priors
  psi ~ dunif(0,1)
  mu.p1 ~ dunif(0, 1) # could replace with a logistic model
  
  ######################### Seasonality shared effect
  beta1 ~ dunif(-182, 182) # peak detectability/activity: zero = 1 July
  beta2 ~ T(dt(0, 1, 1), 0, 500) # Half Cauchy. Stdev of phenology. At sd=500 the curve is entirely flat
  beta3 <- 1/max(f_JD[1:365]) # scaling parameter to ensure that beta3 * f_JD = 1 at the peak of the phenology, i.e. where cJulDate = beta1
  
  for (d in 1:365){
    f_JD[d] <- 1/((2*3.14159265359)^0.5 * beta2) * exp(-((d - (beta1+182))^2 / (2* beta2^2)))
  }
  
  #########################  derived parameters
  psi.fs <- mean(z[1:nsite])
})
```


Next step is to simulate some data for that model
```{r}
# set the parameters for a simulation
mcSim <- nimbleModel(modelcode,
                     constants = list(nsite = nSites, nvisit = nVisits),
                     data = list(nT = array(data = 5, dim = c(nSites, nVisits)),
                                cJulDate = round(array(runif(n = nSites*nVisits, min = -80, max = 120), dim = c(nSites, nVisits)), 0)
                                ),
                     inits = as.list(sim.pars)
                     )

# plot the dependencies of the model in a graph (only makes sense when the model is very simple)
#library(igraph)
#plot(mcSim$getGraph())

CmcSim <- compileNimble(mcSim) # note that we compile the operational model not the code!
nodesToSim <- CmcSim$getDependencies(c("psi", "p1"),
                                           self = F, downstream = T)
#nodesToSim
CmcSim$simulate(nodesToSim)

CmcSim$y1
#CmcSim$isData('y1') # still FALSE!

# Determining the nodes and variables in a model
#CmcSim$getVarNames()

#note that lifted nodes can also correspond to different parametrizations
#CmcSim$getNodeNames()

# Query the model's relationships
#CmcSim$getDependencies(c('psi'))
```


Summarise the simulated data
```{r }
#(simSum <- summariseSimData(data))
#bugs_data <- getBUGSdata(data)
occSites <- with(CmcSim, apply(cbind(y1), 1, max)>0)
(simSum  <- c(
    naiveOcc = mean(occSites),
    reportingRate = mean(with(CmcSim, y1/nT)), # per pan trap
    #meanCount = mean(data$transectData),
    reportingRate_1 = mean(with(CmcSim, y1/nT)[occSites,])#, # per pan trap
    #meanCount_1 = mean(data$transectData[occSites,])
))
```


Now run the model
```{r runModel}
# step 1 create an operational from from NIMBLE/JAGS/BUGS code
model <- nimbleModel(code = modelcode, 
                     constants = list(nsite = nSites, nvisit = nVisits),
                     data = list(y1 = CmcSim$y1,
                                 nT = array(data = 5, dim = c(nSites, nVisits)),
                                 cJulDate = round(array(runif(n = nSites*nVisits, min = -80, max = 120), dim = c(nSites, nVisits)), 0)
                                 ), 
                     inits = list(z = apply(CmcSim$y1 > 0, 1, max), 
                                  psi = simSum["naiveOcc"], 
                                  p1 = simSum["reportingRate_1"]))

# I thought it would be possible to fit the model directly on mcSim, but this doesn't seem to be possible

# step 2 build an MCMC object using buildMCMC(). we can add some customization here
occMCMC <- buildMCMC(model, 
                     monitors = c('psi','mu.p1', "psi.fs", "beta1", "beta2"), 
                     thin = 3, 
                     useConjugacy = FALSE) # useConjugacy controls whether conjugate samplers are assigned when possible

# you can now run the mcmc (Uncompiled MCMC will be really slow)
#runMCMC(occMCMC, niter = 5)

# step 3 before compiling the MCMC object we need to compile the model first
Cmodel <- compileNimble(model) # NJBI: I don't understand why this step is necessary

# now the MCMC (project = NIMBLE model already associated with a project)
CoccMCMC <- compileNimble(occMCMC, project = model)

# and now we can use either $run or runMCMC() on the compiled model object.
runMCMC_samples <- runMCMC(CoccMCMC, nburnin = 1000, niter = 2000, nchains = 3, samplesAsCodaMCMC = T)
```

Plots the MCMC traces
```{r diagnoseModel}
plot1 <- runMCMC_samples %>% ggs() %>% ggs_traceplot(greek = TRUE)
plot2 <- runMCMC_samples %>% ggs() %>% ggs_density(greek = TRUE)
gridExtra::grid.arrange(plot1, plot2, ncol=2)
```

Question: where do I find Rhat?

How do these compare with the simulated values?
```{r}
print(sim.pars)
```

plot detection phenology
```{r}
#sparta::plot_DetectionPhenology(model = model)
```